# RISC-V-Multi-cycle-APB-MCU

🚀 RISC-V/APB 기반 MCU 설계 (RISC-V/APB based MCU Design)본 프로젝트는 RISC-V RV32I Multi-Cycle CPU와 AMBA APB 프로토콜을 기반으로 여러 주변 장치(Peripheral)를 통합한 마이크로컨트롤러 유닛(MCU) 시스템을 SystemVerilog로 설계 및 구현한 결과물입니다.1. 프로젝트 개요 (Project Overview)목표 및 특징프로젝트 목표: RV32I Multi-Cycle CPU 및 AMBA Bus Protocol을 사용하여 여러 주변 장치를 제어할 수 있는 MCU 시스템을 설계하고, SystemVerilog Testbench를 통해 검증하며, C 기반 펌웨어를 작성하고 컴파일합니다.핵심 특징:하드웨어 로직이 아닌 ROM에 저장된 **펌웨어(Firmware)**에 따라 동작이 결정되는 임베디드 시스템 구조입니다.AMBA APB Bus를 이용하여 CPU 코어와 주변 장치들을 효율적으로 연결합니다.개발 환경 및 도구구분내용하드웨어Digilent Basys 3 FPGA Board (검증용)소프트웨어Xilinx Vivado, PuTTy언어SystemVerilog (하드웨어), C (펌웨어)2. 시스템 아키텍처 (System Architecture)전체 시스템은 mcu.sv 모듈을 최상위 레벨로 하여 RV32I Core, APB Master, 그리고 APB Slave 주변 장치들로 구성됩니다.2.1. RISC-V RV32I Multi-Cycle CPU CoreRISC-V ISA의 기본 정수 버전인 RV32I를 구현하였으며, 하나의 명령어를 Fetch, Decode, Execute, Memory, Write Back의 여러 단계에 걸쳐 실행하는 Multi-Cycle 방식을 채택하여 클럭 효율을 높였습니다.단계 (Phase)설명 (Action)FetchPC가 가리키는 주소에서 명령어(IR)를 인출하고 PC를 +4로 업데이트합니다.DecodeIR의 레지스터 주소를 해독하고 레지스터 파일에서 데이터를 읽어옵니다.Execute명령어 유형에 따라 ALU 연산을 수행합니다.MemAccessLoad/Store 명령어에 따라 메모리 접근을 수행합니다.Write Back결과를 레지스터 파일에 기록합니다.2.2. AMBA APB Bus저속/저전력 주변 장치 연결에 최적화된 AMBA APB(Advanced Peripheral Bus) 프로토콜을 사용합니다.Master: APB_Master.svSlave: 각 주변 장치에 통합된 APB Slave 인터페이스 (APB_Slave.sv는 일반 템플릿)동작: IDLE $\to$ SETUP $\to$ ACCESS 의 3단계로 전송이 이루어집니다.2.3. 메모리 맵 (Memory Map)APB 주변 장치들은 다음과 같이 메모리 주소에 할당됩니다. (Base Address: 0x1000_0000)주변 장치 (Peripheral)베이스 주소 (Base Address)역할파일명ROM0x0000_0000명령어/펌웨어 저장ROM.svRAM0x1000_0000데이터 저장 공간RAM.svGPO0x1000_1000범용 출력 포트GPO.svGPI0x1000_2000범용 입력 포트GPI.svGPIO0x1000_3000범용 입출력 포트GPIO.svUART0x1000_4000직렬 통신 포트uart.sv3. 주요 구성 요소 (Core Components)파일명설명mcu.sv최상위 모듈. CPU, ROM, APB Master/Slaves를 연결하여 시스템을 통합합니다.CPU_RV32I.svRV32I CPU 코어. DataPath와 ControlUnit을 인스턴스화합니다.DataPath.svCPU의 데이터 경로. 레지스터 파일, ALU, PC 등을 포함합니다.ControlUnit.svCPU의 제어 장치. 명령어에 따라 DataPath의 제어 신호를 생성합니다.APB_Master.svCPU와 APB Bus 간의 통신을 중재합니다.code.memCPU가 실행할 C 기반 펌웨어의 기계어 코드(hex)를 담은 메모리 파일입니다.3.1. 주변 장치 세부 레지스터주변 장치레지스터 주소 (Offset)레지스터 이름역할GPO0x00Control Register (cr)출력 활성화/비활성화 제어0x04Output Data Register (odr)실제 출력 데이터GPI0x00Control Register (cr)입력 활성화/비활성화 제어0x04Input Data Register (idr)실제 입력 데이터 (Read Only)GPIO0x00Control Register (cr)포트 방향 제어 (1:출력, 0:입력)0x04Output Data Register (odr)출력 데이터0x08Input Data Register (idr)입력 데이터 (Read Only)UART0x00Data Register (DR)RX 데이터 읽기 / TX 데이터 쓰기0x04Status Register (SR)상태 플래그 (RXNE: Bit 0, TXC: Bit 1)4. 펌웨어 및 검증 (Firmware & Verification)4.1. C 언어 펌웨어펌웨어(code.mem으로 빌드됨)는 주변 장치를 활용하여 다음과 같이 동작합니다.통신: UART를 통해 주기적으로 현재 상태와 GPO 출력을 시리얼 포트로 전송합니다.제어: GPI 입력을 통해 세팅 모드에 진입하며, UART로 모드를 전환할 수 있도록 설계되었습니다.트러블슈팅: 컴파일러에서 RV32I 세트가 아닌 명령어가 사용되는 문제를 방지하기 위해, 컴파일러 옵션에 -march=rv32i를 명시하여 명령어 세트를 제한했습니다.4.2. SystemVerilog 검증UART 주변 장치를 DUT(Device Under Test)로 설정하고, environment에서 임의의 데이터를 송수신하며 검증을 수행했습니다.RX Pass 조건: send_data == rdata (보낸 데이터와 수신 데이터 일치)TX Pass 조건: wdata == received_data (쓴 데이터와 수신 측 데이터 일치)결과: 총 512회의 TX/RX 사이클 검증에서 All Pass를 확인했습니다.5. 시작하기 (Getting Started)클론: 본 저장소를 로컬 환경에 클론합니다.Bashgit clone [Your-Repo-URL]
도구: Xilinx Vivado (또는 기타 SystemVerilog/FPGA 개발 환경)를 설치합니다.컴파일: Vivado 프로젝트를 생성하고 모든 .sv 파일을 추가합니다.시뮬레이션/합성:시뮬레이션: mcu.sv 또는 UART_Periph의 Testbench를 실행하여 로직을 검증합니다.합성/구현: mcu.sv를 Basys 3 FPGA 보드에 맞게 합성 및 구현하여 실제 동작을 확인합니다.6. 고찰 (Reflections)본 프로젝트를 통해 RV32I ISA의 Multi-Cycle 구현, AMBA APB 프로토콜의 동작 방식, 그리고 이를 활용한 다양한 주변 장치(UART, GPIO 등)의 설계를 학습할 수 있었습니다. 특히, 하드웨어와 펌웨어의 유기적인 연동을 통해 복잡한 임베디드 시스템이 동작하는 원리를 체감하였습니다. 초기 설계 시 RV32I의 제한적인 명령어 세트 때문에 복잡한 기능을 소프트웨어로 구현하는 데 어려움을 겪었으며, 이는 하드웨어와 소프트웨어 간의 **조화로운 설계(Co-Design)**의 중요성을 일깨워주었습니다.
